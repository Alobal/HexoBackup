---
title: 链表
date: 2020-08-04 16:47:11
categories:
- 数据结构
tags:
- 链表
---
# 单链表定义
一种内存中不连续的线性结构，但每个元素是单独的对象，元素之间通过指针链接起来。

##### 参考实现:
```cpp
// Definition for singly-linked list.
struct SinglyListNode {
    int val;
    SinglyListNode *next;
    SinglyListNode(int x) : val(x), next(NULL) {}
};
```

# 单链表操作

### 访问结点
从头部遍历进行访问

- 无法在常量级时间随机访问

- 最坏情况下时间复杂度O(N)


### 插入结点
将``current``插入到``parent->child``之中，成为``parent->current->child``

其中注意维护好``parent->next=current``和``current->next=child``

注意考虑``parent==NULL``的情况

- 时间复杂度O(1)

示意代码:
```cpp
{
    if(parent!=NULL)
    {
        current->next=parent->next;
        parent->next=current;
    }
    else//parent为NULL，即头部插入
    {
        current->next=child;
        head=current;//更新头结点
    }
}
```


### 删除结点
``parent->current->child``中删除``current``。

其中注意维护好``parent->next=child``和``current->next=NULL``

注意考虑``parent==NULL``的情况

- 时间复杂度O(1)

示意代码:
```cpp
{
    if(parent!=NULL)
    {
        parent->next=current->next;
        current->next=NULL;
    }
    else//头部删除
    {
        head=current->next;
        current->next=NULL;
    }
}
```


# 双向链表定义
在单链表的基础上，增加了prev指针指向前一个链表节点

##### 参考实现:
```cpp
struct DoublyListNode
{
    int val;
    DoublyListNode *next,*prev;
    DoublyListNode(int x):val(x),next(NULL),prev(NULL) {}
};
```

# 双向链表操作

### 访问结点
同样只能从头部进行遍历，但是中间可以往回走。

- 不能随机访问
- 最坏时间复杂度O(N)


###  添加结点

和单链表类似，但注意维护好相关链接
- ``parent->next=current``
- ``current->prev=parent``
- ``current->next=child``
- ``child->prev=current``

还要注意parent或者child为NULL的情况

双链表一般考虑带有头尾结点，单向连接链表本体。

- 时间复杂度，找位置O(N)，操作O(1)

示意代码
```cpp
{   //插入作为第i个结点
    //带有头结点
    if(i==1)//插在头部
    {
        current->next=head->next;//[1,,3] 插入2  2接上3 
        if(current->next!=NULL)
            current->next->prev=current;//3 prev接上2

        head->next=current;//头结点 指向 2
    }

    else//插在中间或末尾
    {
        //维护current和child
        current->next=parent->next;
        if(current->next)//末尾检测
            current->next->prev=current;

        //维护parent和current
        parent->next=current;
        current->prev=parent;
    }
    
}
```

### 删除结点
注意维护结点链接，以及注意头尾结点情况
- ``parent->next=current->next``
- ``current->next->prev=parent``
- ``current->next=NULL``
- ``current->prev=NULL``

- 时间复杂度，找位置O(N)，操作O(1)

示意代码
```cpp
{

    if(parent)
        parent->next=current->next;
    else//删除的是第一个结点
        head->next=current->next;
    if(current->next)//避免删除尾结点的时候 访问 空指针->prev
        current->next->prev=parent;

    current->next=NULL;
    current->prev=NULL;



    
}
```



# 相关算法


### 判断链表是否有环
**双指针**————假如有环，快指针将迟早能和慢指针相遇

```cpp
 bool hasCycle(ListNode *head) 
{
    if(head==NULL || head->next==NULL)//空链表或单结点
        return false;

    ListNode* fast=head;
    while(fast!=NULL)
    {
        //快慢指针移动
        fast=fast->next;
        if(fast!=NULL)
            fast=fast->next;
        head=head->next;

        //检查移动后是否相遇
        if(fast==head)
            return true;
    }

    return false;
}
```

### 寻找链表环的入口
[参考题解](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/c-shuang-zhi-zhen-z-by-zrita/)

**双指针**————同上方法等待快慢指针相遇。

##### 第一次相遇时:
- 环外距离 out
- 环内距离 in
- 环长 circle
- 慢指针走过的距离: ``len_s=out+in``
- 快指针走过的距离: ``len_f= out+in+n*circle``

因为``len_f=2*len_s`` 推导出=》``len_s=n * circle``

此时把快指针置零，快慢指针同时走 out 距离。
##### 第二次相遇时：
- 慢指针走过的距离: ``len_s=out``
- 快指针走过的距离: ``len_f= out+n*circle``

即快慢指针在out的末端，也就是环的起点相遇，此时找到环入口。

```cpp
 ListNode *detectCycle(ListNode *head) 
    {
        ListNode* fast=head,*slow=head;
        if(fast==NULL || fast->next==NULL)
            return NULL;
        while(fast && fast->next)//第一次相遇
        {
            fast=fast->next->next;
            slow=slow->next;

            if(fast==slow)
                break;
        }

        if(fast!=slow)//无环
            return NULL;

        //有环
        fast=head;
        while(fast!=slow)//第二次相遇
        {
            fast=fast->next;
            slow=slow->next;
        }

        return slow;
    }
```


### 翻转链表

不断将head后一个移到头部去。

利用一个root维护头部

```cpp
ListNode* reverseList(ListNode* head) 
{
    ListNode* root=new ListNode(0);
    root->next=head;
    while(head && head->next)
    {
        ListNode* temp=head->next;//[1,2,3] 
        head->next=temp->next;//1接上 2的后续

        temp->next=root->next;//2连上 头结点
        root->next=temp;//2作为新的头结点

    }
    return root->next;
}
```