---
title: 栈和队列
date: 2020-08-31 19:07:48
categories:
- 数据结构
---

栈和队列都是一种推广的线性表，根据不同的存取特性可以分为：
- 栈：
    顺序栈
    链栈
    共享栈

- 队列：
    循环队列
    链式队列
    双端队列

# 基础

## 栈

### 栈定义

栈（Stack）是只允许在一端插入或删除操作的线性表。

### 特点
- 是一种线性表
- 后进先出（Last In First Out，LIFO），只允许在栈顶（Top）插入或删除。

### 基本操作
Empty，判空
Push，入栈
Pop，出栈
Top/GetTop，读栈顶

### 顺序存储的栈
用连续存储单元存放元素，另外拿个 top 指示栈顶元素下标。

示例结构如下：
```cpp
struct stack{
    Elemtype data[maxSize];
    int top;
};
```

<!---more--->

入栈：top++; 赋值
出栈：top--; 赋值
栈空：top==-1;
栈满：top==maxSize-1;

具体成员函数的实现，注意保护数组空间溢出的相关问题。

### 共享顺序栈
类似于共享大数组，两个顺序栈分别以数组的最左端和最右端为栈底，往中间生长入栈。

初始化：letfTop==-1; rightTop==maxSize;
栈满： leftTop==rightTop-1;

### 链式存储的栈
便于多个栈共享存储空间和提高效率，且逻辑上不存在栈满溢出。

具体实现看头插尾插，双链表还是单链表，是否带头结点。

> 通常情况下，同一个问题的递归算法效率会比相应的非递归算法更低一些，因为计算机在实际执行过程中会产生一些重复计算。
> 消除递归不一定要使用栈，例如计算斐波那契数只需要一个简单循环。

## 队列

### 队列定义

队列（Queue）只允许在队列头部访问删除，然后在线性表的另一端，即队列尾部插入。

### 特点
- 线性表
- 先进先出（First In First Out，FIFO），队首出，队尾入。

### 基本操作
Empty，判空
Enqueue，入队
DeQueue，出队
GetHead/Front，读队头

### 顺序存储队列
分配一块连续存储单元，另设两个指针：队头指针 front 和队尾指针 rear。

示例结构如下：
```cpp
struct queue{
    ElemType data[maxSize];
    int front,rear;//rear 这里指向尾后
};
```

初始化/判空：front=0; rear=0;
入队：rear 元素赋值；rear++;
出队：读取 front 元素；front++;

易知简单的数组构造队列，很容易导致最后 front，rear 都逐渐逼近数组末端，最终溢出。因此考虑到循环队列的概念。

### 循环队列
即把存储队列的数组看作一个环，队首和队尾指针移动时，自动进行模余处理。

初始化：front=0；rear=0;
队首移动：front=(front+1)%maxSize;
队尾移动：rear=(rear+1)%maxSize;
队列长度：(rear-front+maxSize)%maxSize;
判空：front==rear;
判满：牺牲一个数据空间，用于存放队满的尾后。(rear+1)%maxSize==front;

>如果 rear 指向的是尾，而不是尾后，则判空不需要留下判满的标志空间。

优点：高效利用了固定的数组空间。

### 链式队列
一个同时带有头指针和尾指针的单链表。头指针指向队首结点，尾指针指向队尾结点。

判空：front==NULL && rear==NULL;
入队：新结点利用尾指针插入到尾部；
出队：利用头指针取出头部结点；

优点：链式结构适合元素变动教大的情形，且不存在存储空间满的问题。

### 双端队列
队列两端都允许入队出队操作，既可以作为栈也可以作为队列。

另有受限双端队列：
- 出队受限，两端可入队，只有一端可出队。可当作栈。注意通过入队的邻接关系来检验出队序列。
- 入队受限，两端可出队，一端可入队。入队序列给定，则从序列两边摘除元素以检查出队序列。

### 队列在计算机系统中的作用

- 解决主机与外部设备之间速度不匹配的问题。即缓冲区思想。
- 解决多用户资源竞争问题。即等待队列思想。

# 栈相关算法

## [最小栈的实现](https://leetcode-cn.com/problems/min-stack/)

需要实现一个能随时获取**当前**最小元素的栈。

### 题解思路

一开始想的是维护一个 int min，但是次小值之类的是无法维护的。

首先我们来看看当前最小值是怎么更新的，假设当前最小值是 min_cur：
- 入栈一个比它大的值，那么此时栈当前最小不变。
- 在它上面的比它大的元素出栈，反正没 min_cur 小，因此出了也不影响栈当前最小=min_cur。
- 入栈一个比它小的值，那么栈当前最小更新到新值 min_new。而且在 min_new 上面的情景和 min_cur 一样，不用考虑了。
- 出栈 min_new，则最小值由 min_new 往下的接管，而我们直到 min_new 往下之前一直是 min_cur 管着最小值，因此又回到了 min_cur。

即核心操作是，判断当前入出栈的元素是不是比之前的最小值小。且最小值的更新有着后进先出的特性，后面更新的最小值，必然也会先被出栈，然后返回上一个最小值，因此考虑使用一个**辅助栈**。

辅助栈，存放有史以来的最小值记录，栈顶即当前状态最小值。假设当前最小值是 min_cur：
- 主栈入栈的元素比最小值大时，辅助栈保存的最小值保持不变，重复入栈一个 min_cur。
- 较小时，更新当前最小值，入栈一个 min_new。
- 出栈时，辅助栈跟随主栈相应出栈。

## [每日温度](https://leetcode-cn.com/leetbook/read/queue-stack/genw3/)——单调栈
请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

气温列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

### 题解思路

有点类似接雨水的题目，要在一系列顺序高度中，找到一个凹区间。且易知较矮的凹区间，必然包含在较高的凹区间内（最外层区间除外）。

换句话说，假如有 temperatures[i],temperatures[i+1] 两个气温：
- temperatures[i+1] > temperatures[i]，则 i+1 就是 i 的新高温
- temperatures[i+1] < temperatures[i]，则 i+1 的新高温肯定比 i 的新高温更先出现，即有点后进先出的特性，考虑用栈。

遍历 temperatures，并且维护一个栈：
- 如果当前元素比栈顶元素小，那么它的新高温肯定比栈顶元素先出现，因此压入栈顶。
- 如果当前元素比栈顶元素大，那么它可以作为栈顶元素的新高温，并且也可能是栈顶往下的元素的新高温，保持出栈，直到比当前栈顶元素小。

### 题解代码

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) 
    {
        stack<int> lower;//保存的是下标而不是值，便于下标相减
        vector<int> result(T.size(),0);//结果数组
        lower.push(0);
        for(int i=1;i<T.size();i++)
        {
            while(!lower.empty() && T[i]>T[lower.top()])//把所有比它小的出栈，并且计算差值
            {
                result[lower.top()]=i-lower.top();
                lower.pop();
            }

            lower.push(i);
        }

        return result;
    }
};
```

## 栈模拟队列
栈后进先出，队列先进先出，容易想到通过两个栈的负负得正实现。假设有 S1，S2 两个栈。
S1 用来入队，S2 用来出队。

### 双栈负负得正

出栈时，先把原 S1 栈里所有元素倒进另一个栈 S2，这样队首是在 S2 的顶部，即可出栈队首元素。

入栈时，则再把 S2 这些元素倒回去，此时队尾在 S1 的顶部，把元素压入即可。

### 优化

考虑到，入栈时把 S2 元素倒回 S1 挺浪费效率的，因为出栈时又得倒过来。

而且值得注意的是，S2 元素倒给 S1，S1 压入 N 个元素，再全部倒回 S2，原 S2 元素还是在 S2 的顶部，即压入对其出队不产生影响。因此每次将 S1 的元素倒给 S2 后，就不必要再拿回来了。S1 该压栈压栈，S2 该出栈出栈，S2 空了再把 S1 现有元素全部倒过去。

## 中缀运算表达式转后缀表达式

准备两个栈，一个运算数栈，一个运算符栈。

从左到右依次扫描中缀表达式每个元素：

1. 如果是'('，则入栈。
2. 如果是')', 则持续出栈运算，直到出了一个'('。
3. 是其他运算符，如果比栈顶运算符优先级高，压栈。如果比栈顶优先级低，则先出栈运算，再比较新的栈顶。

出栈运算：出栈一个运算符和两个运算数进行运算，把运算结果压回运算数栈。

# 队列相关算法

## 树层次遍历——典型 BFS

先将 Root 入队，之后每出队一个结点，则同时把其孩子结点入队。因为先进先出的特性，下一层的结点必然会在这一层结点之后遍历，即实现了层次遍历。

可以考虑在每层开始时，记录一个 queue.size(), 此时可以获得当前层长度，可用于进行每层的输出分割。

## [打开轮盘锁——可优化成双向 BFS](https://leetcode-cn.com/problems/open-the-lock)
你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有 10 个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为  '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。

锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。

列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。

字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。

### 基础 BFS 解法
每个位置有两个滚动方向，四个位置即每个状态可以有 2*4=8 个移动方向。我们要最短次数到达 target，即完成一个最短路径搜索问题。容易想到就是 BFS 了。

BFS 需要注意几个点：
- 因为位置可以往回滚动，要限制不能走回头路，利用 set 判重。
- 需要记录层次深度，考虑队列添加 null 结点或者记录当前层次大小的办法。
- 当前状态滚动到 target 状态是有趋向的，因此可以考虑通过每个位置的距离决定应该优先朝上还是朝下滚，当然由于 deadends 的存在，不能只滚优先的那边。

### 双向 BFS 解法 

由于单向 BFS 是金字塔结构，越往里每个层次的数越来越多，甚至是指数级增长，搜索难度越来越大。末端每增加一个层次的搜索开销，是前期层次开销的指数倍。

因此考虑从起点和 target 点两端同时 BFS，即多进行前期层次的搜索，减少后期末端层次的搜索。相对而言即是用倍数级开销替代了指数级开销。

双向 BFS 注意：
- 搜索终点是两个 BFS 相交，因此要使用 set 进行交集判断。
