---
title: C++函数
date: 2020-08-17 09:08:19
categories:
- C++
tags:
- C++
---

# 基础

函数是可以复用的代码块，通过事先定义和声明，然后在别的地方直接调用进行处理。

## 函数的结构

典型的函数一般包括：返回类型，函数名字，形参列表，函数体。形参列表写在一对``()``内，用``,``隔开。函数体内则是书写需要执行的代码操作。

我们使用**调用运算符（call operator）**``()``执行函数。它作用于一个函数或者指向函数的指针。``()``内书写实参，同样由``,``隔开，实参数量和类型需要和形参有序一一对应。最终这个调用函数表达式的类型就是函数的返回类型。

函数使用前和其他名字一样，需要进行声明。函数声明也叫做**函数原型（function prototype）**，声明对比定义来说，不需要包括函数体，直接用一个``;``替代。

 <!-- more --> 

### 形参
形参是函数定义时，对想要传递的参数变量的临时性名字。

形参列表可以为空，但是不能省略。如下可用两种方式表达空形参列表：
```cpp
void f1(){···}          //隐式定义空列表
void f2(void){···}      //显式定义空列表
```

每个形参都是一个独立的含有声明符的声明，因此每个形参都需要写出相应类型，即使几个形参类型一样。当然，形参变量名不能有重名冲突，否则你用起来怎么分得清呢。

```cpp
int f3(int v1,int v2){···}    //正确
int f4(int v1,v2){···}          //错误
```

形参名是可选的，但是没有名字实际上你根本调用不了这个形参。而且即使不会用到这个形参，但假如真反人类的设置了无名形参，调用函数时依然必须给它传递参数。

### 返回类型
大多可用的类型都可作为返回类型，使用一种特殊的返回类型``void``表明函数不返回任何东西。

返回类型不能是数组类型或者函数类型，但可以是指向数组或函数的指针。

## 局部对象
回忆一下 C++中名字的**作用域**和**生命周期**的概念

- 作用域：名字在所属的作用域中可见可用。
- 生命周期：对象在程序中存活的一段时间。

函数体是一块语句块，而语句块会构成一个新的作用域。因此内部变量和函数形参变量，都是仅在函数内部可见，称之为**局部变量（local variable）**。

函数外部变量的生命周期通常随程序开始随程序结束，局部变量的生命周期依赖于它的定义方式。

### 自动对象
即最普通大众的局部变量。通过函数内部的定义语句自动创建对象，到达函数体的块末尾时自动销毁对象，称为**自动对象（automatic object）**。自动对象销毁后，其值就变成了未定义的。

形参是自动对象。

### 局部静态对象

有些时候，我们需要保留一些对象在函数体结束后依然使用，因此我们可以定义**局部静态对象（local static object）**。定义时使用``static``将其声明为静态类型。

这种对象在第一次经过定义定义语句时创建，直到程序终止才销毁。

局部静态变量如果没有显式的初始化值，将执行**值初始化**，内置类型的值初始化为 0。

一个简单的例子，这个程序会输出 1~10 的数字。
```cpp
size_t count_calls()
{
    static size_t num=0;
    num++;
    return num;
}

int main()
{
    for(size_t i=0;i<10;i++)
        cout<<count_calls()<<endl;
    return 0;
}
```

# 参数传递
每次调用函数都会重新创建形参，并通过传入的实参对形参进行初始化。

而形参的类型决定了传递方式的区别。

当形参是引用类型时，产生**引用传递（passed by reference）**，引用形参是它绑定实参的别名。

其他类型时，则是通过拷贝运算，将实参拷贝给形参，这两个对象通常是相互独立的，这种方式叫做**值传递（passed by value）**。

为了避免传参的拷贝，可以使用引用传递进行避免资源的浪费。

## 指针形参

指针类型的行为和其他非引用类型一样，传递会对指针本身的值进行拷贝。因此实参和形参是两个不同的指针，但是他们指向的对象是同一个。

因此可以通过传递指针对实参进行修改，不过 C++中使用引用传递修改实参更加方便。

## const 形参和实参

实参初始化形参会忽略掉顶层 const，是不是 const 实参都可以传递给 const 形参，即可降格兼容。

例如``void fcn(const int i)``可接受``int``和``const int``的实参。

>顶层 const 和底层 const 是在指针层面才有意义。顶层 const 修饰指针本身的值，即指向位置不能被修改，底层 const 修饰指针指向的对象的值不能被修改。
>
>对于其他类型，顶层 const 即修饰该类型不可修改。

但是由于会忽略顶层 const，因此两个函数不能通过顶层 const 进行区别，如果其他定义也一样的话，会造成重复定义，例如：
```cpp
void fcn1(const int i){···}
void fcn1(int i){···}           //错误，重复定义

void fcn2( int * const i){···}  //忽略顶层 const
void fcn2(int * i){···}         //错误，重复定义

void fcn3(const int * i){···}    //这是底层 const，不会造成重复定义
void fcn3(int * i){···}          //正确
```

### 指针或引用形参与 const

形参初始化和变量初始化一样，关于 const 的要求都是可降格兼容，不能升格。即如上``int``可用于初始化``const int``变量，``const int ``不能初始化``int``变量。

引用和指针层面也是类似，``const int``引用可绑定到``int``对象，``int``引用不可绑定到``const int ``对象。

例如：
```cpp
//假设有两个 fcn 函数，一个需要 int *参数，一个需要 int&参数。
int i=0;
const int consti=i;
fcn(&i);                //调用形参类型 int *的函数
fcn(&consti);           //错误，const int *不能传给 int*
fcn(i);                 //调用 int&的函数
fcn(consti);            //错误，int&引用不能绑定到 const int 对象
fcn(217);               //错误，字面值是常量，int&引用不能绑定到字面值。
```

### 尽量使用常量引用

使用常量引用可以避免拷贝数据，同时阻止非必要的修改操作。

另一方面由于外部的 const 类型不能升格传参给非 const 形参，容易发生类型匹配错误。而外部的非 const 类型可以传给 const 形参，因此使用 const 引用，也可以有效减少这种类型错误的情况。

## 数组形参

数组有两个特殊性质，影响我们对数组的传参操作：

- 数组不能进行拷贝
- 使用数组时相当于使用指针

所以我们不能值传递数组，但是我们可以通过指针进行传递：

三个等价的传递数组的函数，看起来不一样，其实都是形参都是 const int*

```cpp
//会互相造成重复定义错误
void fcn(const int * a);
void fcn(const int a[]);
void fcn(const int a[10]);//这里数组大小只是一个期望大小，有没有完全一样，和没有的会造成重复定义。

int i=0,a[2]={0,1};
fcn(&i);    //int* 转换为 const int *调用
fcn(a);     //数组名转换为指针进行调用
```

但是正如示例所述，一维数组大小只是个期望值，我们不知道传参的数组有多大，因此可以通过别的途径传递长度信息。

```cpp
void fcn(const int a[],int length);//用另一个变量标记长度
void fcn(const int *begin,const int * end)//标准库规范做法，传递尾后元素，进行尾后检测
```

但是注意，二维及往上的数组大小属于一种数据类型范畴，需要严格对应，例如：
```cpp
void fcn(int a[][2])
{
    return ;
}

int a[2][4];

fcn(a);//错误，int (*)[4] 和 int(*)[2] 类型的形参不兼容
```

记住，数组名变量的值即一维首元素类型的地址。

### 引用数组形参
假如我们要修改传参的数组，可以传递非常量指针，也可以进行引用绑定。

注意数组引用的格式，不同于一般情况下由右到左的阅读类型声明，数组最好是由内向外阅读类型声明。

如下，阅读起来首先看 ptr 是否带有括号，括号内是否注明 ``*`` 或者 ``&`` ，然后看括号右边元素个数是多少，最后看括号左边数组元素类型。

- ``int *ptr[10];``——ptr 是一个数组名，数组元素是 int*。
- ``int (*ptr)[10];``——ptr 是一个指针，指向含有 10 个元素的数组，数组元素是 int。
- ``int (&ptr)[10];``——ptr 是一个对数组的引用，数组含有 10 个元素，数组元素是 int。
- ``int &ptr[10];``——错误用法

>注意数组元素个数是严格要求的。

引用数组的形参方式，例如：
```cpp
void fcn(int (&arr)[10])        //arr 是 10 个 int 的数组的引用，注意传参时元素个数严格要求
void fcn(int &arr[10])          //错误用法。
```

### 多维数组
我们知道多维数组其实就是一维数组，只不过数组元素是新数组指针而已。

我们在传参一维数组时，只是传参了首元素的地址及其类型，而多维数组也是类似，无非是首元素类型是一个数组类型而已。

示例如下，首先明确传参的只是一个指针，指向首元素，这个指针的类型是首元素类型。
```cpp
void fcn(int (* matrix)[10]);   //matrix 是一个指针，指向首元素类型为 int[10]
void fcn(int matrix[][10]);     //等价形式，前面示例知道 matrix[] 其实也是看作指针。
void fcn(int * matrix[10])      //错误，这是一个一维数组，首元素类型是 int*
```

>可能有人有疑问，既然是二维数组，为什么形参不是``int * matrix[] `` 或者``int ** ``呢——matrix 是一个指针，指向元素是新的指针，而这个新指针则是第二维的首元素地址，一切看起来很符合二维数组的设定？
>
>然而注意此时 matrix 的类型是``int **``，即指向``int *``的指针，而我们需要的正确 matrix 类型是``int (*) [len]``，即指向``int [len]``的指针，这两者在传参上是不同的。
>
>搞糊涂的话只需要关注数组首元素类型即可，二维数组首元素类型是``int (*) [len]``，不是``int *``。

## main 的传参
我们知道 main 是外部访问该程序的入口，因此也可以通过 main 向想调用的程序进行传参。

外部参数通过两个形参传给 main 函数：``int main(int argc,char *argv[])``

- argv 是一个数组，每个数组元素是 C 风格的字符串，即二维数组，因此等价于 char **argv。
- argc 是 argv 数组的长度

实际使用时，argv[0] 通常为程序名，或者空字符串，以 argv[1] 开始的才是命令行中以空格分割的参数。
argv 最后会追加一个固定元素，它的值是``0``。

## 可变数量形参

有时候我们不确定要传递几个实参给函数，因此 C++提供了两种方法处理不同数量的实参进行调用函数。

### Initializer_list 形参
数量未知但全部实参类型相同，可以使用 Initializer_list 标准库类型，用于表示特定类型的值的数组。

Initializer_list 是一个很简单的模板类，提供`` begin()，end()，size()，= ``几个基础函数功能。

传参给 Initializer_list 时，只需用``{}``把参数序列包括起来即可。

使用示例如下：
```cpp
void error_msg(int count,initializer_list<string> msg){···}

error_msg(217,{"Hello",",","World","!"})
```

函数体内部则可根据 begin，end 成员函数去控制遍历迭代。

### 省略符形参

省略符是为了兼容 C 而设置的。通常不建议在 C 之外使用。

```cpp
void foo(parm_list,...);
void foo(...)
```

# 参考资料
C++ Primer 5 edition 中文版
