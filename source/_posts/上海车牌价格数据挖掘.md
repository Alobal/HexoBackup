---
title: 上海车牌价格数据挖掘
categories:
- DataScience
date: 2020-02-17 02:17:00
---
###    1.导入数据
#####     1.1 数据格式如图:
![数据](https://wx4.sinaimg.cn/mw1024/b8e57787gy1ggtsuvc65uj20j706aglw.jpg)

#####     1.2 pd.read_csv() 注意读取的csv文件的编码

#####     1.3 注意到时间数据是字符串, 想办法转换为date格式:

查询到了pd.to_datetime()可识别大多数日期格式, 但是是要完整的年月日都有, 否则会error.
因此先给所有的日期加一个```"1-"``` , 反正对我们按月分析也影响不大

#####      代码:
```
%matplotlib inline
from pylab import *
import numpy as np
import pandas as pd
from dateutil.parser import parse
import matplotlib.pyplot as plt


df=pd.read_csv("./上海车牌价格.csv")
# 整理时间数据类型
for i in range(0,len(df)):
    df.loc[i,'Date']="1-"+df.iloc[i]['Date']
df['Date']=pd.to_datetime(df['Date'])
```

# 2. 制作概览图
#####      2.1 刚拿到数据, 先尽可能地观察一下全局, 所以我制作了全属性随时间分布的图:
plt.figure 调整画布大小
plot画折线图
scatter画散点图
```
plt.figure(figsize=[12.8,9.6])
plot(df['Date'],df_nom['avg price'],lw=5)
scatter(df['Date'],df_nom['lowest price '],s=20)
scatter(df['Date'],df_nom['Rate'],s=20)
scatter(df['Date'],df_nom['Total number of license issued'],s=20)
scatter(df['Date'],df_nom['Total number of applicants'],s=20)
plt.legend(['avg','low','rate','issued','apply'])
```
效果如下: ![原杂交图](https://wx1.sinaimg.cn/mw1024/b8e57787gy1ggtsuvhugij20ik0b6t8s.jpg)

#####     2.2 发现这个图不太对劲, y轴值高的那个属性完全支配了整张图, 看不出其他属性的变化, 因此要进行归一化处理:
即把除时间外, 所有属性缩放到[0,1]区间:
```
df_nom=df.iloc[:,1:].apply(lambda x: (x - np.min(x)) / (np.max(x) - np.min(x)))
```
然后进行制图, 效果如下: 
![新杂交图](https://wx3.sinaimg.cn/mw1024/b8e57787gy1ggtsuv3hgjj20kv0fsjrx.jpg)

# 3. 制作各属性与平均价格的相关图
#####     3.1 最低价格与平均价格:
![x-最低价格 y-平均价格](https://wx3.sinaimg.cn/mw1024/b8e57787gy1ggtsuuwc53j20lp0gfweg.jpg)

#####     3.2 供需比与平均价格:
注意使用plt.subplot在一张图上创建子图
**subplot(mni) 将整图划分为m行n列, 下张图取从左到右, 从上往下 第 i 块区域**
![左上 供-价格, 右上 需-价格, 下 供需比-价格](https://wx3.sinaimg.cn/mw1024/b8e57787gy1ggtsuuwo3tj20m60g2t94.jpg)

# 4. 多项式拟合 试探时间与价格的关系:
#####     4.1 要拿时间拟合, 时间数据肯定要是实数才行, 因此先转换时间数据:
```
totalx=np.arange(0,len(df["Date"]),1)# 时间转换为0 ,1 ,2 ,3 ...len-1 的数组
trainx=totalx[:-12]
testx=totalx[-12:]
```

#####     4.2 拟合之和还需要检验, 因此要划分测试集和训练集, 这里我取了最后一年的数据为测试集:
```
traindf=df[:-12][['Date','avg price']]
testdf=df[-12:][['Date','avg price']]
```

#####     4.3 多项式拟合:
np.polyfit(x,y,n): 
x横坐标数组, 只能是一个维度
y目标值数组
n多项式最高系数, 显然越高对训练集拟合越高, 也越容易过拟合
```
x=np.array(trainx)
y=np.array(traindf['avg price'])
p=np.poly1d(np.polyfit(x,y,4))
```

######     4.5 制图观察效果, 同时用r2检验评估:
**r2检验:**  体现拟合效果, 意义: 真实数据波动是否能被拟合数据解释
```
# 制图
plot(df['Date'],df['avg price'])
plot(df['Date'],p(totalx),c='r')

# r2检验
checky=np.array(testdf['avg price'])
print("in test r2_score: ",r2_score(checky,p(testx)))
print("in train r2_score: ",r2_score(y,p(trainx)))
```

效果图:
![分别4,3,2 次的多项式拟合](https://wx4.sinaimg.cn/mw1024/b8e57787gy1ggtsuuof94j20xc099gm7.jpg)

# 5. 线性回归:
#####      1. 线性回归即用1次多系数的多项式拟合Y
$$Y=a_0+a_1x_1+a_2x_2....+a_nx_n$$
#####      2. 同样划分测试训练集, 然后使用fit进行拟合:
```
# 线性回归
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
# 数据导入
feature_cols=['Total number of license issued','Total number of applicants']
x=df[feature_cols]
y=df['avg price']
x['time']=totalx
# 数据分割测试集和训练集
x_train=x[:-48]
x_test=x[-48:]
y_train=y[:-48]
y_test=y[-48:]
linreg=LinearRegression()
linreg.fit(x_train,y_train)

# 观察线性回归模型系数
print (linreg.intercept_)
print(linreg.coef_)
```

#####     3. 制图观察效果:
**linreg.predict(x) 计算x的预测值**
```
# 检验线性回归
from sklearn import metrics
y_pre=linreg.predict(x_test)
print(metrics.r2_score(y_test,y_pre))

y_pred=linreg.predict(x)
plt.figure(figsize=[12.8,9.6])
plot(df['Date'],y_pred,lw=3)
plot(df[:-48]['Date'],df[:-48]['avg price'])
plot(df[-48:]['Date'],df[-48:]['avg price'])
plt.legend(["Predict","Train Origin","Test Origin"])
```

效果如下: 
![线性回归拟合](https://wx2.sinaimg.cn/mw1024/b8e57787gy1ggtsuuox3wj20kk0et3yn.jpg)
