---
title: 计算机视觉实验2-1——目标轮廓提取,-复制目标
categories:
- OpenCV-python
date: 2020-02-17 02:17:00
---
![原图](https://wx3.sinaimg.cn/mw1024/b8e57787gy1ggttahhdrsj20qo0m841e.jpg)

# 目标: 复制图中的这棵树
 1. 我们肯定先要提取树, 然后才能复制
2. 怎么提取呢?我想的是先找到树的轮廓, 然后把树的轮廓内所有像素都遍历复制一遍就好了.
>好像更应该使用连通域的概念, 而不是轮廓查找. 有兴趣可以试试
3. 轮廓怎么识别呢? 有个findContours函数可以自动查找轮廓, 但是很容易就把各种树叶缝隙, 各种坑坑洼洼识别成了轮廓, 所以要预处理一下, 清理不必要的信息.

# 1. 图像预处理
findContours要求传入的图像是二值的, 因此我们先要对原图灰度化, 并且进行阈值分割成二值图像.

**读取图片, 灰度化处理:**
```
from cv2 import cv2
import matplotlib.pyplot as plt
img=cv2.imread("./tree.jpg")

# 灰度 阈值分割二值化处理
grey=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
cv2.imshow("grey",grey)
```
![GREY](https://wx1.sinaimg.cn/mw1024/b8e57787gy1ggttahfejhj20r60ndgny.jpg)

**阈值分割:**
这里注意用了个**高斯模糊**去噪, 可以在分割时避免坑坑洼洼的噪音, 和树叶的不完整性.

cv2.THRESH_BINARY_INV, cv2.THRESH_OTSU 是一些处理参数: 
- 前者决定了阈值反转处理, 即超过阈值的置0, 低于阈值的置255
- 后者决定了使用OTSU阈值进行分割
```
grey=cv2.GaussianBlur(grey,(5,5),0)# 高斯模糊 去噪
ret,theimg=cv2.threshold(grey,0,255,cv2.THRESH_BINARY_INV+cv2.THRESH_OTSU)
cv2.imshow("theimg",theimg)# 阈值二值化图
```
![BIN](https://wx3.sinaimg.cn/mw1024/b8e57787gy1ggttahdk20j20r60nddg6.jpg)

# 2. 运用findContours轮廓识别
#####     contours, hier=findContours(srcimg, mode, method)
- 返回值contours,是查找到的所有轮廓信息
- 返回值hier, 是所有轮廓信息的层级关系, 这里因为是找外轮廓, 不需要
- srcimg, 输入的二值图像
- mode, 查找模式, 例如RETR_EXTERNAL是仅查找外轮廓, 其他的模式自行了解
- method, 轮廓信息的近似方法, 就决定怎么存下查找的轮廓, 例如CHAIN_APPROX_NONE 是存储所有轮廓点
- CHAIN_APPROX_SIMPLE 压缩, 将每个方向的所有点由 起点 和 终点 , 两个点代替

>实际切割的时候发现树根和地面难以分割, 会识别成一个大轮廓, 腐蚀膨胀操作也没能处理好, 因此用上了简单粗暴的办法, 手动把土地部分切掉.
```
# 因为树和地连在一起不好分离, 手动切割
height,width=theimg.shape
treeimg=theimg[:int(2*height/3)-30,:]# 提取出不包含地面的上部分
# 轮廓提取
contours,hier=cv2.findContours(treeimg,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
```

# 3. 提取出树的轮廓
我们目前有了图中所有的轮廓信息, 然而即使预处理已经解决了很多噪音, 还是有识别出几十个轮廓
**因此我们要对轮廓进行筛选处理** , 这里我使用的是面积筛选, 大概测试几次, 就能找出树轮廓的面积范围, 然后进行筛选.

cv2.contourArea(contour) , 计算轮廓面积
cv2.drawContours(drawimg,contours,i,color,thick), 绘制函数
  - 在drawimg图上直接绘制
  - contours即传入所有轮廓
  - i为绘制的轮廓在contours中的下标, 如果为负则绘制所有轮廓
  - color, thick ,绘制的颜色 粗细

```
#  #在原图上画出轮廓, 并且找出属于树的轮廓
treei=0
for i in range(len(contours)):
    area=cv2.contourArea(contours[i])
    if(area>500 and area<30000):# 面积筛选出树的轮廓标号
        drawimg=img.copy()# 拿张图来画个轮廓示意
        cv2.drawContours(drawimg,contours,i,(0,0,255),3)
        cv2.imshow("Contours of Tree",drawimg)
        treei=i
        break
```

![轮廓效果](https://wx3.sinaimg.cn/mw1024/b8e57787gy1ggttahewhzj20r60ndmzv.jpg)

# 4. 轮廓内像素复制
关键问题在于, 如何判断像素是否在轮廓内:
cv2.pointPolygonTest(contour, point, flag):
- contour , 比较的轮廓
- point, 比较的点, 注意图像坐标系, 例如img[i][j] 实际上是(j, i) 点
- flag, True时会计算和轮廓的距离, False则仅判断是否在轮廓内
- 返回 1 在轮廓内, 0 在轮廓上, -1 轮廓外

另外这里注意我们可以通过```cv2.boundingRect```找到轮廓的边界信息, 返回 x, y , w, h, 分别是轮廓左上角的(x, y), 宽度w, 高度h, 即描述了一个轮廓的外接矩形信息.

有了边界信息, 就可以在边界内遍历, 不需要遍历整张图片

最后将轮廓内的点复制到想要的地方即可
```
x,y,w,h=cv2.boundingRect(contours[treei])# 获取轮廓四边界, 这样只需要在里面遍历, 不需要遍历整张图
# 将轮廓内的点复制到左边
for i in range(y,y+h):
    for j in range(x,x+w):
        if(cv2.pointPolygonTest(contours[treei],(j,i),False)==1):# 测试点是否在轮廓内的函数
            img[i+10,j-500]=img[i,j].copy()# 偏移左边
```



![最终效果](https://wx1.sinaimg.cn/mw1024/b8e57787gy1ggttahfmcij20qr0mvgmu.jpg)
