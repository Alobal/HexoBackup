---
title: 简书博客导入hexo
date: 2020-07-16 19:02:54
tags:
---

# 1. 下载原markdown集

登录简书作者后台，在个人设置--账号管理--打包下载所有文章。
此时可以获得以文集为文件夹的所有markdown文章源文件

# 2. 利用shell脚本添加hexo元数据
需要掌握 **sed修改文件**，**shell脚本运行**
- [**sed命令用法**](https://www.cnblogs.com/maxincai/p/5146338.html)
- shell脚本只要你安装好了git环境，即可在命令行中通过 ``sh xxx.sh`` 运行相关脚本，至于怎么去写，有兴趣可以自己了解

以下是我使用的shell脚本：

```sh
for f in ./*/*;do
sed -i  's/#####\([^#]\)/##### \1/' $f
sed -i  's/####\([^#]\)/#### \1/' $f
sed -i  's/###\([^#]\)/### \1/' $f
sed -i  's/##\([^#]\)/## \1/' $f
sed -i  's/#\([^#]\)/# \1/' $f
base=$(basename $f .md)
categories=$(basename $(dirname $f) $PWD)
insert="---\ntitle: ${base}\ncategories:\n- ${categories}\ndate:2020-02-17 02:17:00\n---\n"
echo -e "${insert}$(cat $f)" > $f
done
```
- 前半段为sed在#字符后添加空格，因为在简书里 ``#紧贴标题`` 也是可以成功识别的，但是其他的markdown不一定支持。这里注意需要用到的命令格式为``sed -i 's/old/new' file ``
- - \-i指在源文件上修改
- - s 指进行文本替换，但这里有一个巨大的坑点，假如old长度为3，new长度为4，那么该命令会吞掉原old后的一个字符，即它的替换是覆盖式替换，而不是删除old后插入new。
- - 因此需要使用到 () 格式，()在old中选定子字符串，然后在new中利用\\number，获取第number个子字符串，即我们保存下来了会被覆盖掉的字符，然后又重新给他加了回去。
- - 为了避免在诸如#####中匹配出单个#，利用了[^c]，即不匹配c字符，在这段代码中就是下一个不能是#。
- 后半段是hexo文档评论区的大神写的，获取了目录名作为hexo的分类名，并且插入元数据，**注意无法自动维护简书的时间**，因此我这自己选了个日期插入。

# 3.运行脚本并检查文档
在简书文集解压出来的文件夹的根目录中，即在``user-xxxx``文件夹下，运行该脚本，等待运行完成后检查修改结果是否符合你的预期。

# 4.存在问题
1. 无法维护时间
2. 简书代码块不需要注明语言，但是这样hexo的一些highlight就无法识别，想不到自动注明语言的办法。