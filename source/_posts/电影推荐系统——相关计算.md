---
title: 电影推荐系统——相关计算
categories:
- DataScience
date: 2020-02-17 02:17:00
---
#  6 电影推荐系统

###    1. 导入数据
- ####     read_csv需要注意names,usecols参数的使用,encoding也需要设置,utf-8打不开u.item
- ####     merge 类似于sql表连接,有各种参数设置, 什么左连右连内连, 连接规则等.....
```
import pandas as pd
# user评分表
r_cols=['user_id','movie_id','rating']
ratings=pd.read_csv("C:\Users\Sitch\Downloads\DataScienceCourse\ml-100k\u.data",sep='	',names=r_cols,usecols=range(3),encoding="ISO-8859-1")
# movie的id和title对应表
m_cols=['movie_id','title']
movies=pd.read_csv("C:\Users\Sitch\Downloads\DataScienceCourse\ml-100k\u.item",sep='|',names=m_cols,usecols=range(2),encoding="ISO-8859-1")
# 连接两表
ratings=pd.merge(ratings,movies)
ratings.head()
```

###    2. 转换成矩阵表
- ####     pivot_table生成数据透视表(感觉像数据分组聚合),index为聚合键\[1级,2级....], values为需要的数据,columns指定列,要求长度和values相同
```
movieRatings=ratings.pivot_table(index=['user_id'],columns=['title'],values='rating')
movieRatings.head()
```

###    3. 协同过滤
- ###    df.corrwith(other,axis=,method=)用于计算DataFrame中列或行 与 other 的相关性。axis=0/'index'计算列相关, 1/'columns'计算行相关, method为计算方法
- ###    pandas.series类型, 注意不是二维数组, 类似于数据类型为'index':values的带索引列表,series\[i]是values\[i]. series\['index']是对应value

```
starWarsRatings=movieRatings['Star Wars (1977)'] # Star wars 评分表
similar2starWars=movieRatings.corrwith(starWarsRatings)
similar2starWars=similar2starWars.dropna()
df=pd.DataFrame(similar2starWars)
df.sort_values(0,ascending=False)
```

###    4. 优化——冷门问题
- ####     agg({'col':[func,func,func....]}) agg聚合操作,可以指定聚合函数,也可以用{}指定特定列特定聚合方法
- ####     dataframe存在多级索引多级column, 可以参考下面
```
import numpy as np
movieStats=ratings.groupby('title').agg({'rating':[np.size,np.mean]})
movieStats.head()
```

###    可以发现有些电影评分人数很少,此时的均分意义不大
- ####     df.join(other,on=,how=,...) 连接other和self, 返回df形式, other可以是df也可以是pandas.Series. 如果是Series, 传递前需要设置好Series.name属性(用作连接后的列名), on, how 为规则方式设置
```
popularMovies=movieStats['rating']['size']>=100 # size大于100的index+T/F列表
#  movieStats[popularMovies].sort_values([('rating','mean')],ascending=False)[:15] #显示筛选后的表 , mutiindex需要指定两层
similar2starWars.name='similarity'
df=movieStats[popularMovies].join(similar2starWars)
df.sort_values(['similarity'],ascending=False)[:15]

```

###    5. 整理成推荐电影系统
- ####     df.corr()计算df中任意两列的相关系数,返回矩阵df, 可设置method, min_periods最小样本量
- - ####     method: perison : 计算线性相关, Kendall : 计算分类数据相关, 即无序数据, spearman : 计算非线性,非正太分布相关
```
import pandas as pd
# user评分表
r_cols=['user_id','movie_id','rating']
ratings=pd.read_csv("C:\Users\Sitch\Downloads\DataScienceCourse\ml-100k\u.data",sep='	',names=r_cols,usecols=range(3),encoding="ISO-8859-1")
# movie的id和title对应表
m_cols=['movie_id','title']
movies=pd.read_csv("C:\Users\Sitch\Downloads\DataScienceCourse\ml-100k\u.item",sep='|',names=m_cols,usecols=range(2),encoding="ISO-8859-1")
# 连接两表
ratings=pd.merge(ratings,movies)

# 按user_id生成聚合图
userRatings=ratings.pivot_table(index=['user_id'],columns=['title'],values='rating')
# 生成相关系数矩阵
corrMatrix=userRatings.corr(method='pearson',min_periods=150)

testuser=userRatings.loc[0].dropna()

def GenerateSimCandidates(myRatings):
    simCandidates=pd.Series()
    for i in range(0,len(myRatings.index)):
        print("Adding sims for "+ myRatings.index[i]+"...")
        # 筛选出myRatings.index[i]作为列标题的一整列
        sims=corrMatrix[myRatings.index[i]].dropna()
        # 评分加权,这一列所有value乘上评分
        sims=sims.map(lambda x:x*myRatings[i])
        simCandidates=simCandidates.append(sims)

    
    # 聚合重复项
    simCandidates=simCandidates.groupby(simCandidates.index).sum()
    # 整理排序    
    simCandidates.sort_values(inplace=True,ascending=False)
    return simCandidates
        
print(GenerateSimCandidates(testuser).head(10))

```
