---
title: 数组
date: 2020-08-04 14:48:35
categories:
- 数据结构
tags:
- 数组
---

# 一维数组
计算机会在内存中申请一段连续的空间，并且返回索引为 0 处的地址作为数组名。

## 数组操作

### 读取元素
通过访问下标索引实现，索引一般从 0 开始。一般数组名是数组首元素地址。

元素地址=数组首地址+偏移量

- 时间复杂度 O(1)

### 查找元素
无序状态下，顺序搜索
- 时间复杂度 O(N)

有序状态下，考虑二分查找
- 时间复杂度 O(log N)

### 插入/删除 元素
插入/删除 数组末尾空白位置，直接下标访问
- 时间复杂度 O(1)

在中间 插入/删除，考虑数组是否有多余空间，然后还需要移动 前/后 元素
- 时间复杂度 O(N)

# 二维数组

二维数组本质上也是一维数组

如下例所示：

可以看到二维数组的第一维存储的是第二维数组首地址。

且每行的末尾和下一行的开头是连在一起的。

如下 ``a[0][1]`` 后紧接的即是 ``a[1][0]``

```cpp
int a[2][2] = { {0,0 }, { 0,0 }};

cout << a[0]<<" "<<a[1]<<" "<<&a[0][0]<<" "<<&a[0][1];

//一个 int 占 4 字节，输出如下：00B8FBCC 00B8FBD4 00B8FBCC 00B8FBD0
```

# 一个数组中实现的多重表
在一个大数组中，维护 front[3],last[3]，每对 front 和 last 分别代表一个线性表的实际区间。

这样的好处是多个线性表能够共享存储空间，且进行空间扩展和收缩时很方便。

但是插入操作在最坏情况下的用时会大大增加。

# 相关算法

## 查找两个升序数组的中位数

[之前的题解分析](https://alobal.github.io/Blog/2020/02/17/LeetCode-No-4-/)

遍历找第 k 个数肯定是不行的。确定中位数，即变相要同时划分两个数组，左边所有数小于右边所有数，且数量关系要保持好，这样划分的边界即是中位数。

划分点的确定可用二分查找，时间 O（log n）。

## 找数组中的众数

排序直接定位数组一半的位置，时间 O（nlogn）。

[两两抵消算法](https://alobal.github.io/Blog/2020/07/20/LeetCode-%E5%89%91%E6%8C%87Offer-No-39/)，时间 O（n）
